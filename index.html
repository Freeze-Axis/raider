<!DOCTYPE html>
<html lang="ja">
<head>
<!----------------------------------------------------------------->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#a9ceec" />

  <title>Freeze è’ã‚‰ã—ãƒ„ãƒ¼ãƒ«</title>
  <meta name="description" content="Discordã§æ´»å‹•ã™ã‚‹å¤šç›®çš„ã‚°ãƒ«ãƒ¼ãƒ—â€œFreezeâ€ã®å…¬å¼ã‚µã‚¤ãƒˆã§ã™ã€‚" />

  <link rel="icon" href="https://i.ibb.co/LyFxxY5/freeze.png" />

  <!-- Open Graph -->
  <meta property="og:type"        content="website" />
  <meta property="og:site_name"   content="Freeze" />
  <meta property="og:title"       content="Webãƒ„ãƒ¼ãƒ«" />
  <meta property="og:description" content="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ãƒ„ãƒ¼ãƒ«" />
  <meta property="og:url"         content="" />
  <meta property="og:image"       content="" />
<!----------------------------------------------------------------->

    <!-- Google Fonts: Roboto Mono -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
      /* åŸºæœ¬ãƒªã‚»ãƒƒãƒˆ */
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body {
        font-family: 'Roboto Mono', monospace;
        background: #121212;
        color: #e0e0e0;
        line-height: 1.4;
        padding: 5px;
        font-size: 0.9rem;
        text-align: left;
      }
      /* ã‚³ãƒ³ãƒ†ãƒŠï¼ˆå·¦å¯„ã›ãƒ»ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆï¼‰ */
      .container {
        max-width: 600px;
        margin: 5px 0;
        padding: 5px;
      }
      /* ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã‚«ãƒ¼ãƒ‰ */
      .accordion {
        background: #1f1f1f;
        border: 1px solid #333;
        border-radius: 4px;
        margin-bottom: 8px;
        overflow: hidden;
        transition: transform 0.2s;
      }
      .accordion-header {
        padding: 8px 12px;
        background: linear-gradient(90deg, #00c6ff, #0072ff);
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
      }
      .accordion-header h2 {
        font-size: 0.9rem;
        margin: 0;
        color: #121212;
      }
      .accordion-header .toggle-icon {
        font-size: 1rem;
        transition: transform 0.3s;
        color: #121212;
      }
      .accordion-content {
        padding: 8px 12px;
        display: none;
        background: #1f1f1f;
      }
      .accordion-content.active { display: block; }
      /* ãƒ•ã‚©ãƒ¼ãƒ è¦ç´  */
      label {
        display: block;
        margin-bottom: 2px;
        font-weight: 700;
        font-size: 0.8rem;
        color: #00c6ff;
        cursor: help;
      }
      input[type="text"],
      input[type="number"],
      textarea,
      select {
        width: 100%;
        padding: 6px;
        margin-bottom: 6px;
        border: 1px solid #00c6ff;
        border-radius: 2px;
        background: #2a2a2a;
        color: #e0e0e0;
        font-size: 0.8rem;
        transition: border-color 0.2s;
      }
      input[type="text"]:focus,
      input[type="number"]:focus,
      textarea:focus,
      select:focus {
        border-color: #00a3d9;
        outline: none;
      }
      textarea { resize: vertical; }
      .checkbox-group {
        display: flex;
        align-items: center;
        margin-bottom: 6px;
      }
      .checkbox-group input[type="checkbox"] {
        margin-right: 4px;
        width: 14px;
        height: 14px;
        accent-color: #00c6ff;
      }
      /* ãƒœã‚¿ãƒ³ */
      .btn {
        display: inline-block;
        padding: 6px 12px;
        font-size: 0.8rem;
        font-weight: bold;
        border: none;
        border-radius: 2px;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s;
        margin-top: 2px;
        background: linear-gradient(90deg, #00c6ff, #0072ff);
        color: #121212;
        box-shadow: 0 1px 2px rgba(0,0,0,0.5);
      }
      .btn:hover { 
        background: linear-gradient(90deg, #00a3d9, #005bb5);
        box-shadow: 0 2px 4px rgba(0,0,0,0.7);
      }
      .btn:disabled { background: #555; cursor: not-allowed; }
      /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚¨ãƒªã‚¢ */
      .status-box {
        background: #1f1f1f;
        border: 1px solid #00c6ff;
        border-radius: 2px;
        padding: 8px;
        margin-top: 8px;
        min-height: 100px;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-size: 0.75rem;
      }
      /* ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ— */
      label.tooltip:hover::after {
        content: attr(data-tip);
        position: absolute;
        background: #333;
        color: #fff;
        padding: 4px 6px;
        border-radius: 2px;
        top: -28px;
        font-size: 0.7rem;
        white-space: nowrap;
        opacity: 0.9;
      }
      /* â–¼ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¨­å®šç”¨ã‚¹ã‚¿ã‚¤ãƒ« â–¼ */
      .message-settings-container {
        padding: 10px;
        border: 1px solid #00c6ff;
        border-radius: 4px;
        background-color: #181818;
        margin-top: 8px;
      }
      .message-settings-container h3 {
        margin-bottom: 8px;
        color: #00c6ff;
      }
      .delay-settings {
        border: 1px solid #00c6ff;
        padding: 8px;
        margin-top: 8px;
        border-radius: 4px;
        background-color: #1a1a1a;
      }
      .execution-buttons {
        margin-top: 10px;
        text-align: center;
      }
      .thread-execution-buttons {
        margin-top: 10px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <form id="botForm">
        <!-- TOKENè¨­å®š -->
        <div class="accordion" id="botServer">
          <div class="accordion-header">
            <h2>TOKENè¨­å®š</h2>
            <span class="toggle-icon">ï¼‹</span>
          </div>
          <div class="accordion-content">
            <!-- ãƒˆãƒ¼ã‚¯ãƒ³ã¯å¸¸ã«è¡¨ç¤º -->
            <label for="tokenInput" class="tooltip" data-tip="å„è¡Œã«1ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›">Botãƒˆãƒ¼ã‚¯ãƒ³</label>
            <textarea id="tokenInput" name="token" rows="3" placeholder="TOKEN1&#10;TOKEN2"></textarea>
          </div>
        </div>
        
        <!-- IDè¨­å®šï¼ˆã‚µãƒ¼ãƒãƒ¼IDå«ã‚€ï¼‰ -->
        <div class="accordion" id="channel">
          <div class="accordion-header">
            <h2>IDè¨­å®š</h2>
            <span class="toggle-icon">ï¼‹</span>
          </div>
          <div class="accordion-content">
            <label for="serverId" class="tooltip" data-tip="ä¾‹ï¼š123456789012345678">ã‚µãƒ¼ãƒãƒ¼ID</label>
            <input type="text" id="serverId" name="serverId" placeholder="ã‚µãƒ¼ãƒãƒ¼IDã‚’å…¥åŠ›">
            <div class="checkbox-group">
              <input type="checkbox" id="sendToAllChannels" name="sendToAllChannels">
              <label for="sendToAllChannels">å…¨ãƒãƒ£ãƒ³ãƒãƒ«ã«ãƒ©ãƒ³ãƒ€ãƒ é€ä¿¡ï¼ˆè‡ªå‹•å–å¾—ï¼‰</label>
            </div>
            <div id="manualChannelDiv">
              <label for="channelIds" class="tooltip" data-tip="å„è¡Œã«1ã¤ã®ãƒãƒ£ãƒ³ãƒãƒ«IDã‚’å…¥åŠ›">ãƒãƒ£ãƒ³ãƒãƒ«IDï¼ˆæ”¹è¡ŒåŒºåˆ‡ã‚Šï¼‰</label>
              <textarea id="channelIds" name="channelIds" rows="2" placeholder="ä¾‹ï¼š123456789012345678&#10;234567890123456789"></textarea>
            </div>
            <fieldset style="border:1px solid #00c6ff; padding: 8px; margin-top: 8px;">
              <legend style="padding: 0 4px; color: #00c6ff; font-size: 0.8rem;">ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—</legend>
              <label for="userIds" class="tooltip" data-tip="å–å¾—ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¯å„è¡Œã«è¡¨ç¤ºã•ã‚Œã¾ã™">å–å¾—æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ID</label>
              <textarea id="userIds" name="userIds" rows="2" placeholder="ã“ã“ã«å–å¾—ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒè¡¨ç¤ºã•ã‚Œã¾ã™"></textarea>
              <button type="button" class="btn" id="fetchUserIdsButton">ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—</button>
            </fieldset>
            <label for="reactionChannelId" class="tooltip" data-tip="ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«ä½¿ç”¨ã™ã‚‹ãƒãƒ£ãƒ³ãƒãƒ«IDã‚’å…¥åŠ›">ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ£ãƒ³ãƒãƒ«ID</label>
            <textarea id="reactionChannelIds" name="reactionChannelIds" rows="3" placeholder="ä¾‹ï¼š123456789012345678&#10;234567890123456789"></textarea>
            <button type="button" class="btn" id="fetchReactionChannelIdButton">ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ£ãƒ³ãƒãƒ«IDã‚’å–å¾—</button>
          </div>
        </div>
        
        <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¨­å®š -->
        <div class="accordion" id="message">
          <div class="accordion-header">
            <h2>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¨­å®š</h2>
            <span class="toggle-icon">ï¼‹</span>
          </div>
          <div class="accordion-content">
            <div class="message-settings-container">
              <h3>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¨­å®š</h3>
              <label for="messageContent" class="tooltip" data-tip="é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ¬æ–‡">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹</label>
              <textarea id="messageContent" name="messageContent" rows="2" placeholder="é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"></textarea>
              <div class="checkbox-group">
                <input type="checkbox" id="appendRandomString" name="appendRandomString">
                <label for="appendRandomString">æœ«å°¾ã«ãƒ©ãƒ³ãƒ€ãƒ æ–‡å­—è¿½åŠ </label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="mentionRandomUsers" name="mentionRandomUsers">
                <label for="mentionRandomUsers">ãƒ©ãƒ³ãƒ€ãƒ ã«ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³</label>
              </div>
              <label for="mentionCount" class="tooltip" data-tip="1ï½50ã®ç¯„å›²ã§è¨­å®š">ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³æ•°</label>
              <input type="number" id="mentionCount" name="mentionCount" min="1" max="50" value="1">
              <fieldset style="border:1px solid #00c6ff; padding: 8px; margin-top: 8px; border-radius:4px;">
                <legend style="padding: 0 4px; color: #00c6ff; font-size: 0.8rem;">ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ï¼šæŠ•ç¥¨è¨­å®šã€‘</legend>
                <div class="checkbox-group">
                  <input type="checkbox" id="includePoll" name="includePoll">
                  <label for="includePoll">æŠ•ç¥¨ã‚’å«ã‚€</label>
                </div>
                <div id="pollFields" style="display: none;">
                  <label for="pollQuestion" class="tooltip" data-tip="æŠ•ç¥¨ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›">æŠ•ç¥¨ã‚¿ã‚¤ãƒˆãƒ«</label>
                  <input type="text" id="pollQuestion" name="pollQuestion" placeholder="æŠ•ç¥¨ã®ã‚¿ã‚¤ãƒˆãƒ«">
                  <label for="pollAnswers" class="tooltip" data-tip="ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§è¤‡æ•°å›ç­”ã‚’å…¥åŠ›">æŠ•ç¥¨ã®å›ç­”</label>
                  <input type="text" id="pollAnswers" name="pollAnswers" placeholder="ä¾‹ï¼šå›ç­”1,å›ç­”2,å›ç­”3">
                  <label for="pollDuration" class="tooltip" data-tip="æŠ•ç¥¨ã®é–‹å‚¬æœŸé–“ï¼ˆå˜ä½ï¼šæ™‚é–“ï¼‰">é–‹å‚¬æœŸé–“</label>
                  <select id="pollDuration" name="pollDuration">
                    <option value="1">1æ™‚é–“</option>
                    <option value="4">4æ™‚é–“</option>
                    <option value="8">8æ™‚é–“</option>
                    <option value="24">24æ™‚é–“</option>
                    <option value="72">3æ—¥é–“</option>
                    <option value="168">1é€±é–“</option>
                    <option value="336">2é€±é–“</option>
                  </select>
                  <div class="checkbox-group">
                    <input type="checkbox" id="expirePoll" name="expirePoll">
                    <label for="expirePoll">æŠ•ç¥¨ã‚’å³æ™‚çµ‚äº†</label>
                  </div>
                </div>
              </fieldset>
              <div class="delay-settings">
                <div class="checkbox-group">
                  <input type="checkbox" id="enableDelay" name="enableDelay">
                  <label for="enableDelay">é…å»¶ã‚’æœ‰åŠ¹ã«ã™ã‚‹</label>
                </div>
                <label for="delay" class="tooltip" data-tip="é€ä¿¡é…å»¶ï¼ˆãƒŸãƒªç§’ï¼‰ã€‚ä¾‹ï¼š1000 ã¯ 1 ç§’">é€ä¿¡é…å»¶ï¼ˆãƒŸãƒªç§’ï¼‰</label>
                <input type="number" id="delay" name="delay" step="1" value="0" placeholder="ä¾‹ï¼š1000">
              </div>
              <div class="execution-buttons">
                <button type="submit" class="btn" id="executeBtn">å®Ÿè¡Œ</button>
                <button type="button" class="btn" id="stopButton" disabled>åœæ­¢</button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆ -->
        <div class="accordion" id="threadCreation">
          <div class="accordion-header">
            <h2>ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆ</h2>
            <span class="toggle-icon">ï¼‹</span>
          </div>
          <div class="accordion-content">
            <label for="threadTitle" class="tooltip" data-tip="ä½œæˆã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¿ã‚¤ãƒˆãƒ«">ã‚¹ãƒ¬ãƒƒãƒ‰ã‚¿ã‚¤ãƒˆãƒ«</label>
            <input type="text" id="threadTitle" name="threadTitle" placeholder="ã‚¹ãƒ¬ãƒƒãƒ‰ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›">
            <label for="threadMessage" class="tooltip" data-tip="ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã«é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸">ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</label>
            <textarea id="threadMessage" name="threadMessage" rows="2" placeholder="ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"></textarea>
            <div class="checkbox-group">
              <input type="checkbox" id="threadMentionRandomUsers" name="threadMentionRandomUsers">
              <label for="threadMentionRandomUsers">ãƒ©ãƒ³ãƒ€ãƒ ã«ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³</label>
            </div>
            <label for="threadMentionCount" class="tooltip" data-tip="1ï½50ã®ç¯„å›²ã§è¨­å®š">ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³æ•°</label>
            <input type="number" id="threadMentionCount" name="threadMentionCount" min="1" max="50" value="1">
            <label for="threadCount" class="tooltip" data-tip="ä½œæˆå›æ•°ã‚’æŒ‡å®š">ä½œæˆå›æ•°</label>
            <input type="number" id="threadCount" name="threadCount" value="1">
            <div class="delay-settings">
              <div class="checkbox-group">
                <input type="checkbox" id="threadEnableDelay" name="threadEnableDelay">
                <label for="threadEnableDelay">é…å»¶ã‚’æœ‰åŠ¹ã«ã™ã‚‹</label>
              </div>
              <label for="threadDelay" class="tooltip" data-tip="å„ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆã®é…å»¶ï¼ˆãƒŸãƒªç§’ï¼‰ã€‚ä¾‹ï¼š1000 ã¯ 1 ç§’">é…å»¶ï¼ˆãƒŸãƒªç§’ï¼‰</label>
              <input type="number" id="threadDelay" name="threadDelay" value="0" placeholder="ä¾‹ï¼š1000">
            </div>
            <p style="font-size:0.8rem; color:#00c6ff;">â€»ã‚¹ãƒ¬ãƒƒãƒ‰ã®typeã¯è‡ªå‹•åˆ¤åˆ¥ã•ã‚Œã¾ã™</p>
            <div class="thread-execution-buttons">
              <button type="button" class="btn" id="startThreadBtn">ã‚¹ãƒ¬ãƒƒãƒ‰é€ä¿¡é–‹å§‹</button>
              <button type="button" class="btn" id="stopThreadBtn" disabled>ã‚¹ãƒ¬ãƒƒãƒ‰åœæ­¢</button>
            </div>
          </div>
        </div>
        
        <!-- ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ -->
        <div class="accordion" id="reaction">
          <div class="accordion-header">
            <h2>ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³</h2>
            <span class="toggle-icon">ï¼‹</span>
          </div>
          <div class="accordion-content">
            <label for="normalEmojis" class="tooltip" data-tip="é€šå¸¸çµµæ–‡å­—ã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§å…¥åŠ›">é€šå¸¸çµµæ–‡å­—</label>
            <input type="text" id="normalEmojis" name="normalEmojis" placeholder="ä¾‹ï¼šğŸ˜€,ğŸ˜,ğŸ‘">
            <label for="customEmojis" class="tooltip" data-tip="ã‚«ã‚¹ã‚¿ãƒ çµµæ–‡å­—ã‚’æ”¹è¡ŒåŒºåˆ‡ã‚Šã§å…¥åŠ›">ã‚«ã‚¹ã‚¿ãƒ çµµæ–‡å­—</label>
            <textarea id="customEmojis" name="customEmojis" rows="3" placeholder="ä¾‹ï¼šcustom1&#10;custom2"></textarea>
            <label for="reactionMessageCount" class="tooltip" data-tip="ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä»˜ã‘ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°">å¯¾è±¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</label>
            <input type="number" id="reactionMessageCount" name="reactionMessageCount" min="1" value="1">
            <div class="checkbox-group">
              <input type="checkbox" id="allMessages" name="allMessages">
              <label for="allMessages">å…¨ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¯¾è±¡ã«ã™ã‚‹</label>
            </div>
            <div class="delay-settings">
              <div class="checkbox-group">
                <input type="checkbox" id="reactionEnableDelay" name="reactionEnableDelay">
                <label for="reactionEnableDelay">é…å»¶ã‚’æœ‰åŠ¹ã«ã™ã‚‹</label>
              </div>
              <label for="reactionDelay" class="tooltip" data-tip="ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é…å»¶ï¼ˆãƒŸãƒªç§’ï¼‰ã€‚ä¾‹ï¼š1000 ã¯ 1 ç§’">é…å»¶ï¼ˆãƒŸãƒªç§’ï¼‰</label>
              <input type="number" id="reactionDelay" name="reactionDelay" value="0" placeholder="ä¾‹ï¼š1000">
            </div>
            <div class="execution-buttons">
              <button type="button" class="btn" id="startReactionBtn">ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡é–‹å§‹</button>
              <button type="button" class="btn" id="stopReactionBtn" disabled>ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³åœæ­¢</button>
            </div>
          </div>
        </div>
      </form>
      
      <!-- ãƒ­ã‚°è¡¨ç¤º -->
      <div style="font-size: 0.9rem; color: #00c6ff; margin-top:10px;">ãƒ­ã‚°</div>
      <div class="status-box" id="status">å‡¦ç†å¾…æ©Ÿä¸­...</div>
    </div>
    
    <!-- axios CDN -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
      (function(){
        "use strict";
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ åœæ­¢å‡¦ç†å¯¾å¿œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // åœæ­¢ãƒ•ãƒ©ã‚°ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ç”¨ï¼‰
        let isStopped = false;
        // ã‚¹ãƒ¬ãƒƒãƒ‰é€ä¿¡ç”¨åœæ­¢ãƒ•ãƒ©ã‚°
        let threadIsStopped = false;
        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³åœæ­¢ç”¨ãƒ•ãƒ©ã‚°
        let reactionIsStopped = false;
        
        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ãªå¾…æ©Ÿé–¢æ•°ï¼ˆæŒ‡å®šã•ã‚ŒãŸåœæ­¢ãƒ•ãƒ©ã‚°ã‚’å®šæœŸãƒã‚§ãƒƒã‚¯ï¼‰
        function sleepWithStop(ms, stopChecker) {
          return new Promise(resolve => {
            const start = Date.now();
            function check() {
              if (stopChecker()) {
                resolve();
              } else if (Date.now() - start >= ms) {
                resolve();
              } else {
                setTimeout(check, 50);
              }
            }
            check();
          });
        }
        
        // retryRequestï¼šåœæ­¢ãƒ•ãƒ©ã‚°å¯¾å¿œç‰ˆ
        async function retryRequest(requestFunc, delay = 1000, stopChecker = () => false) {
          while (true) {
            if (stopChecker()) {
              // throw new Error("å‡¦ç†åœæ­¢ã•ã‚Œã¾ã—ãŸã€‚");
              const stopError = new Error("å‡¦ç†åœæ­¢ã•ã‚Œã¾ã—ãŸã€‚");
              stopError.isStopped = true;
              throw stopError;
            }
            try {
              return await requestFunc();
            } catch (error) {
              if (stopChecker()) {
                // throw new Error("å‡¦ç†åœæ­¢ã•ã‚Œã¾ã—ãŸã€‚");
                const stopError = new Error("å‡¦ç†åœæ­¢ã•ã‚Œã¾ã—ãŸã€‚");
                stopError.isStopped = true;
                throw stopError;
              }
              if (error.response && (error.response.status === 401 || error.response.status === 403)) {
                throw error; // â† axiosã®errorã‚’ãã®ã¾ã¾æŠ•ã’ã‚‹
              } else if (error.response && error.response.status === 429) {
                const retryAfter = error.response.data.retry_after || delay / 1000;
                updateStatus(`ãƒ¬ãƒ¼ãƒˆåˆ¶é™: ${retryAfter}ç§’å¾Œã«å†è©¦è¡Œ`, true);
                await sleepWithStop(retryAfter * 1000, stopChecker);
              } else if (error.response && error.response.status === 400 && error.response.data && error.response.data.code === 10014) {
                throw error; // â† 400/10014ã¯å¤–ã«æŠ•ã’ã‚‹
              } else if (error.response && error.response.status === 404) {
                throw error; // â† 404ã‚‚å¤–ã«æŠ•ã’ã‚‹
              } else if (error.message === "Network Error") {
                updateStatus("ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã€‚å†è©¦è¡Œã—ã¾ã™ã€‚", true);
                await sleepWithStop(delay, stopChecker);
              } else {
                updateStatus(`ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
                await sleepWithStop(delay, stopChecker);
              }
            }
          }
        }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function getTokens() {
          return tokenInput.value.split("\n").map(t => t.trim()).filter(t => t);
        }
        
        function generateMentionString(userIdsText, count) {
          const userIds = userIdsText.split("\n").map(id => id.trim()).filter(id => id);
          if (!userIds.length) return "";
          const effectiveCount = Math.min(count, userIds.length);
          const shuffled = userIds.slice().sort(() => 0.5 - Math.random());
          const selected = shuffled.slice(0, effectiveCount);
          const mentions = selected.map(id => `<@${id}>`);
          const lines = [];
          for (let i = 0; i < mentions.length; i += 3) {
            lines.push(mentions.slice(i, i + 3).join(" "));
          }
          return lines.join("\n");
        }
        
        function checkAndRemoveInvalidToken(error, tokens, index) {
          if (error.response && (error.response.status === 401 || error.response.status === 403)) {
            updateStatus(`TOKEN[${tokens[index]}]ã¯ä½¿ç”¨ä¸å¯ã¨åˆ¤æ–­ã•ã‚Œã¾ã—ãŸã€‚ä»¥é™ã“ã®TOKENã§ã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¡Œã„ã¾ã›ã‚“ã€‚`, true);
            tokens.splice(index, 1);
            return true;
          }
          return false;
        }
        
        function throwIfInvalidToken(error, token) {
          if (error.response && (error.response.status === 401 || error.response.status === 403)) {
            updateStatus(`TOKEN[${token}]ã¯ä½¿ç”¨ä¸å¯ã¨åˆ¤æ–­ã•ã‚ŒãŸãŸã‚ã€ä»¥é™ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯é€ä¿¡ã—ã¾ã›ã‚“ã€‚`, true);
            throw error;
          }
        }
        
        // getChannelsForServer ã®ä¿®æ­£ï¼šç¬¬ä¸‰å¼•æ•°ã§åœæ­¢ãƒã‚§ãƒƒã‚¯é–¢æ•°ã‚’æ¸¡ã›ã‚‹ã‚ˆã†ã«
        async function getChannelsForServer(serverId, tokens, stopChecker = () => isStopped) {
          for (let i = 0; i < tokens.length; i++) {
            try {
              const resp = await retryRequest(() =>
                axios.get(`https://discord.com/api/v9/guilds/${serverId}/channels`, {
                  headers: { Authorization: tokens[i] }
                }), 1000, stopChecker);
              const channels = resp.data.filter(ch => [0, 2, 5].includes(ch.type)).map(ch => ch.id);
              if (channels.length > 0) {
                return { channels, tokenIndex: i };
              } else {
                updateStatus("é€ä¿¡å¯èƒ½ãªãƒãƒ£ãƒ³ãƒãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", true);
              }
            } catch (error) {
              if (checkAndRemoveInvalidToken(error, tokens, i)) { i--; }
              else { updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ«å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, true); }
            }
          }
          return null;
        }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æ—¢å­˜å‡¦ç† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        // ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³çŠ¶æ…‹ç®¡ç†
        const savedAccordionStates = JSON.parse(localStorage.getItem("accordionStates") || "{}");
        document.querySelectorAll('.accordion').forEach(accordion => {
          const header = accordion.querySelector('.accordion-header');
          const content = accordion.querySelector('.accordion-content');
          const icon = header.querySelector('.toggle-icon');
          const id = accordion.id;
          if (savedAccordionStates[id]) {
            content.classList.add('active');
            icon.textContent = 'âˆ’';
          } else {
            content.classList.remove('active');
            icon.textContent = 'ï¼‹';
          }
          header.addEventListener('click', function() {
            if (content.classList.contains('active')) {
              content.classList.remove('active');
              icon.textContent = 'ï¼‹';
              savedAccordionStates[id] = false;
            } else {
              content.classList.add('active');
              icon.textContent = 'âˆ’';
              savedAccordionStates[id] = true;
            }
            localStorage.setItem("accordionStates", JSON.stringify(savedAccordionStates));
          });
        });
        
        // ãƒ•ã‚©ãƒ¼ãƒ è‡ªå‹•ä¿å­˜
        let processRunning = false;
        let lastErrorMessage = "";
        const form = document.getElementById("botForm");
        function saveFormData() {
          const formData = {};
          new FormData(form).forEach((value, key) => { formData[key] = value; });
          localStorage.setItem("botFormData", JSON.stringify(formData));
        }
        function loadFormData() {
          const saved = localStorage.getItem("botFormData");
          if (saved) {
            const data = JSON.parse(saved);
            Object.keys(data).forEach(key => {
              if (form.elements[key]) {
                if (form.elements[key].type === "checkbox") {
                  form.elements[key].checked = data[key] === "on";
                } else {
                  form.elements[key].value = data[key];
                }
              }
            });
          }
        }
        form.addEventListener("input", saveFormData);
        loadFormData();
        
        const sendAllCheckbox = document.getElementById("sendToAllChannels");
        const manualChannelDiv = document.getElementById("manualChannelDiv");
        function updateChannelInput() {
          manualChannelDiv.style.display = sendAllCheckbox.checked ? "none" : "block";
        }
        sendAllCheckbox.addEventListener("change", updateChannelInput);
        updateChannelInput();
        
        const includePollCheckbox = document.getElementById("includePoll");
        const pollFields = document.getElementById("pollFields");
        pollFields.style.display = includePollCheckbox.checked ? "block" : "none";
        includePollCheckbox.addEventListener("change", function() {
          pollFields.style.display = this.checked ? "block" : "none";
        });
        
        document.getElementById("stopButton").disabled = true;
        document.getElementById("stopThreadBtn").disabled = true;
        document.getElementById("stopReactionBtn").disabled = true;
        
        // â€»TOKENå…¥åŠ›ã¯å¸¸ã«è¡¨ç¤ºã™ã‚‹ãŸã‚ã€éš ã™æ©Ÿèƒ½ã¯å‰Šé™¤
        
        // ãƒ­ã‚°æ›´æ–°
        function updateStatus(message, isError = false) {
          if (message === lastErrorMessage) return;
          lastErrorMessage = message;
          const statusEl = document.getElementById("status");
          const div = document.createElement("div");
          div.innerText = message;
          div.style.color = isError ? "#ff6b6b" : "#e0e0e0";
          statusEl.appendChild(div);
          statusEl.scrollTop = statusEl.scrollHeight;
        }
        
        function generateRandomString(length) {
          const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          let result = "";
          for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          return result;
        }
        
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å‡¦ç†ç”¨é–¢æ•°ï¼ˆåœæ­¢ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
        async function sendMessageToChannels(message, channelIds, token) {
          const headers = { Authorization: token, "Content-Type": "application/json" };
          for (const channelId of channelIds) {
            try {
              const data = { content: message };
              await retryRequest(() => axios.post(`https://discord.com/api/v10/channels/${channelId}/messages`, data, { headers }), 1000, () => isStopped);
            } catch (error) {
              throwIfInvalidToken(error, token);
              updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã¸ã®é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
            }
          }
        }
        
        async function sendPollData(pollData, channelIds, token) {
          const headers = { Authorization: token, "Content-Type": "application/json" };
          for (const channelId of channelIds) {
            try {
              const response = await retryRequest(() => axios.post(`https://discord.com/api/v10/channels/${channelId}/messages`, pollData, { headers }), 1000, () => isStopped);
              if (response && response.data) return response;
              else throw new Error("ç„¡åŠ¹ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹");
            } catch (error) {
              throwIfInvalidToken(error, token);
              updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã¸ã®æŠ•ç¥¨é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
            }
          }
        }
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—å‡¦ç†
        document.getElementById("fetchUserIdsButton").addEventListener("click", async function () {
          const serverId = document.getElementById("serverId").value.trim();
          const tokenVal = getTokens()[0] || "";
          if (!serverId) { updateStatus("ã‚µãƒ¼ãƒãƒ¼IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", true); return; }
          if (!tokenVal) { updateStatus("Botãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", true); return; }
          
          let tokens = getTokens();
          // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—æ™‚ã¯åœæ­¢ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã‚ãªã„
          const channelRes = await getChannelsForServer(serverId, tokens, () => false);
          if (!channelRes) {
            updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒãªã„ãŸã‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚", true);
            return;
          }
          const channelIds = channelRes.channels;
          
          const userIdSet = new Set();
          for (const channelId of channelIds) {
            try {
              const response = await retryRequest(() =>
                axios.get(`https://discord.com/api/v10/channels/${channelId}/messages?limit=100`, { headers: { Authorization: tokenVal } }), 1000, () => false);
              const messages = response.data;
              messages.forEach(msg => { if (msg.author && msg.author.id) userIdSet.add(msg.author.id); });
            } catch (error) { }
          }
          const userIds = Array.from(userIdSet);
          document.getElementById("userIds").value = userIds.join("\n");
          updateStatus(`ãƒ¦ãƒ¼ã‚¶ãƒ¼ID ${userIds.length} ä»¶å–å¾—ã—ã¾ã—ãŸã€‚`);
        });
        
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å‡¦ç†
        form.addEventListener("submit", async function (event) {
          event.preventDefault();
          if (processRunning) return;
          processRunning = true;
          isStopped = false;
      
          const execBtn = document.getElementById("executeBtn");
          const stopBtn = document.getElementById("stopButton");
          execBtn.disabled = true;
          stopBtn.disabled = false;
      
          let tokens = getTokens();
          if(tokens.length === 0) { updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒã‚ã‚Šã¾ã›ã‚“ã€‚", true); processRunning = false; return; }
      
          const serverId = document.getElementById("serverId").value.trim();
          const baseMessage = document.getElementById("messageContent").value;
          const delayEnabled = document.getElementById("enableDelay").checked;
          const delay = delayEnabled ? (parseInt(document.getElementById("delay").value, 10) || 0) : 0;
          const appendRandomString = document.getElementById("appendRandomString").checked;
          const mentionRandomUsers = document.getElementById("mentionRandomUsers").checked;
          let mentionCount = parseInt(document.getElementById("mentionCount").value, 10) || 1;
          mentionCount = Math.min(Math.max(mentionCount, 1), 50);
          
          const includePoll = document.getElementById("includePoll").checked;
          const pollQuestion = document.getElementById("pollQuestion").value;
          const pollAnswers = document.getElementById("pollAnswers").value.split(",").map(a => a.trim()).filter(a => a);
          const pollDuration = document.getElementById("pollDuration").value;
          const expirePoll = document.getElementById("expirePoll").checked;
      
          const sendToAllChannels = document.getElementById("sendToAllChannels").checked;
          const manualChannelsText = document.getElementById("channelIds").value.trim();
          const userIdsText = document.getElementById("userIds").value;
      
          let channelsList = [];
          if (sendToAllChannels) {
            const channelRes = await getChannelsForServer(serverId, tokens);
            if (!channelRes) {
              updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒãªã„ãŸã‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚", true);
              processRunning = false;
              execBtn.disabled = false;
              stopBtn.disabled = true;
              return;
            }
            channelsList = channelRes.channels;
          } else {
            const manualIds = manualChannelsText.split("\n").map(id => id.trim()).filter(id => id);
            if (manualIds.length === 0) { updateStatus("ãƒãƒ£ãƒ³ãƒãƒ«IDãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", true); processRunning = false; return; }
            channelsList = manualIds;
          }
      
          updateStatus("å‡¦ç†ä¸­...");
          let tokenIndex = 0;
          while (!isStopped) {
            if(tokens.length === 0) {
              updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒãªããªã‚Šã¾ã—ãŸã€‚");
              break;
            }
            let finalMessage = baseMessage;
            if (mentionRandomUsers) {
              if (userIdsText && userIdsText.trim() !== "") {
                const mentionStr = generateMentionString(userIdsText, mentionCount);
                if (mentionStr) { finalMessage += "\n" + mentionStr; }
                else { updateStatus("ãƒ¦ãƒ¼ã‚¶ãƒ¼IDæ¬„ã«æœ‰åŠ¹ãªIDãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ©ãƒ³ãƒ€ãƒ ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸã€‚"); }
              } else {
                updateStatus("ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€ãƒ©ãƒ³ãƒ€ãƒ ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸã€‚");
              }
            }
            if (appendRandomString) { finalMessage += " " + generateRandomString(8); }
      
            let pollData = null;
            if (includePoll) {
              if (pollQuestion && pollAnswers.length > 0) {
                pollData = {
                  content: finalMessage,
                  poll: {
                    question: { text: pollQuestion },
                    answers: pollAnswers.map(answer => ({ poll_media: { text: answer } })),
                    duration: pollDuration
                  },
                  flags: 0
                };
              }
            }
      
            let targetChannels = [];
            const randomIndex = Math.floor(Math.random() * channelsList.length);
            targetChannels.push(channelsList[randomIndex]);
      
            try {
              if (pollData) {
                const pollResp = await retryRequest(() =>
                  sendPollData(pollData, targetChannels, tokens[tokenIndex]),
                  1000,
                  () => isStopped
                );
                updateStatus("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‹æŠ•ç¥¨ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚");
                if (expirePoll && pollResp && pollResp.data) {
                  const pollId = pollResp.data.id;
                  const channelId = pollResp.data.channel_id;
                  await retryRequest(() =>
                    axios.post(`https://discord.com/api/v9/channels/${channelId}/polls/${pollId}/expire`, {}, { headers: { Authorization: tokens[tokenIndex] } }),
                    1000,
                    () => isStopped
                  );
                  updateStatus("æŠ•ç¥¨ã‚’å³æ™‚çµ‚äº†ã—ã¾ã—ãŸã€‚");
                }
              } else {
                await retryRequest(() =>
                  sendMessageToChannels(finalMessage, targetChannels, tokens[tokenIndex]),
                  1000,
                  () => isStopped
                );
                updateStatus("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚");
              }
            } catch (error) {
              if (error.response && (error.response.status === 401 || error.response.status === 403)) {
                updateStatus(`TOKEN[${tokens[tokenIndex]}] ã¯ä½¿ç”¨ä¸å¯ã¨åˆ¤æ–­ã•ã‚Œã¾ã—ãŸã€‚`, true);
                tokens.splice(tokenIndex, 1);
                if(tokens.length === 0) {
                  updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒãªããªã‚Šã¾ã—ãŸã€‚", true);
                  break;
                }
                tokenIndex = tokenIndex % tokens.length;
                continue;
              } else {
                updateStatus(`é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
              }
            }
            tokenIndex = (tokenIndex + 1) % tokens.length;
            await sleepWithStop(delay, () => isStopped);
          }
          updateStatus("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ãŒåœæ­¢ã—ã¾ã—ãŸã€‚");
          processRunning = false;
          execBtn.disabled = false;
          stopBtn.disabled = true;
        });
        
        document.getElementById("stopButton").addEventListener("click", function () {
          isStopped = true;
          updateStatus("å‡¦ç†ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚");
          processRunning = false;
          document.getElementById("executeBtn").disabled = false;
          this.disabled = true;
        });
        
        // ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆå‡¦ç†
        let threadProcessRunning = false;
        document.getElementById("startThreadBtn").addEventListener("click", async function () {
          if (threadProcessRunning) return;
          threadProcessRunning = true;
          threadIsStopped = false;
          document.getElementById("startThreadBtn").disabled = true;
          document.getElementById("stopThreadBtn").disabled = false;
          
          const threadTitle = document.getElementById("threadTitle").value.trim();
          const threadMessage = document.getElementById("threadMessage").value;
          const threadCount = Number(document.getElementById("threadCount").value) || 1;
          const threadDelayEnabled = document.getElementById("threadEnableDelay").checked;
          const threadDelay = threadDelayEnabled ? (Number(document.getElementById("threadDelay").value) || 0) : 0;
          let tokens = getTokens();
          if (tokens.length === 0) { updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒã‚ã‚Šã¾ã›ã‚“ã€‚", true); threadProcessRunning = false; return; }
          
          let targetChannelId = "";
          const sendToAllChannels = document.getElementById("sendToAllChannels").checked;
          const manualChannelsText = document.getElementById("channelIds").value.trim();
          const serverId = document.getElementById("serverId").value.trim();
          
          if (manualChannelsText) {
            targetChannelId = manualChannelsText.split("\n")[0].trim();
          } else if (sendToAllChannels && serverId) {
            const channelRes = await getChannelsForServer(serverId, tokens);
            if (!channelRes) {
              updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒãªã„ãŸã‚ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚", true);
              threadProcessRunning = false;
              document.getElementById("startThreadBtn").disabled = false;
              document.getElementById("stopThreadBtn").disabled = true;
              return;
            }
            targetChannelId = channelRes.channels[0];
          } else {
            updateStatus("ãƒãƒ£ãƒ³ãƒãƒ«IDã¾ãŸã¯ã‚µãƒ¼ãƒãƒ¼IDãŒå¿…è¦ã§ã™ã€‚", true);
            threadProcessRunning = false;
            return;
          }
          
          let actualThreadType = 11;
          try {
            const channelResp = await retryRequest(() =>
              axios.get(`https://discord.com/api/v9/channels/${targetChannelId}`, {
                headers: { Authorization: tokens[0] }
              }), 1000, () => threadIsStopped);
            const chType = channelResp.data.type;
            actualThreadType = (chType === 5) ? 10 : 11;
            updateStatus(`å¯¾è±¡ãƒãƒ£ãƒ³ãƒãƒ«ã‚¿ã‚¤ãƒ— ${chType} ã«ã‚ˆã‚Šã€ã‚¹ãƒ¬ãƒƒãƒ‰type ã‚’ ${actualThreadType} ã«è¨­å®šã—ã¾ã—ãŸã€‚`);
          } catch (error) {
            updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
          }
          
          updateStatus("ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆå‡¦ç†é–‹å§‹...");
          
          const threadMentionRandomUsers = document.getElementById("threadMentionRandomUsers").checked;
          let threadMentionCount = parseInt(document.getElementById("threadMentionCount").value, 10) || 1;
          threadMentionCount = Math.min(Math.max(threadMentionCount, 1), 50);
          
          let threadTokenIndex = 0;
          for (let i = 0; i < threadCount; i++) {
            if (threadIsStopped) break;
            try {
              const payload = {
                name: threadTitle,
                type: actualThreadType,
                auto_archive_duration: 4320,
                location: "Thread Browser Toolbar"
              };
              const threadResp = await retryRequest(() =>
                axios.post(`https://discord.com/api/v9/channels/${targetChannelId}/threads`, payload, {
                  headers: { Authorization: tokens[threadTokenIndex], "Content-Type": "application/json" }
                }), 1000, () => threadIsStopped);
              if(threadIsStopped) break;
              updateStatus(`ã‚¹ãƒ¬ãƒƒãƒ‰ "${threadTitle}" ä½œæˆå®Œäº† (${i+1}/${threadCount})`);
              
              if (threadMessage.trim() && threadResp.data && threadResp.data.id) {
                let finalThreadMessage = threadMessage;
                if (threadMentionRandomUsers) {
                  const userIdsText = document.getElementById("userIds").value;
                  if (userIdsText && userIdsText.trim() !== "") {
                    const mentionStr = generateMentionString(userIdsText, threadMentionCount);
                    if (mentionStr) { finalThreadMessage += "\n" + mentionStr; }
                    else { updateStatus("ãƒ¦ãƒ¼ã‚¶ãƒ¼IDæ¬„ã«æœ‰åŠ¹ãªIDãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã®ãƒ©ãƒ³ãƒ€ãƒ ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸã€‚"); }
                  } else {
                    updateStatus("ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã®ãƒ©ãƒ³ãƒ€ãƒ ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸã€‚");
                  }
                }
                if(threadIsStopped) break;
                const msgPayload = { content: finalThreadMessage };
                await retryRequest(() =>
                  axios.post(`https://discord.com/api/v10/channels/${threadResp.data.id}/messages`, msgPayload, {
                    headers: { Authorization: tokens[threadTokenIndex], "Content-Type": "application/json" }
                  }), 1000, () => threadIsStopped);
                if(threadIsStopped) break;
                updateStatus(`ã‚¹ãƒ¬ãƒƒãƒ‰å†…ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å®Œäº† (${i+1}/${threadCount})`);
              }
            } catch (error) {
              if (error.response && (error.response.status === 401 || error.response.status === 403)) {
                updateStatus(`TOKEN[${tokens[threadTokenIndex]}] ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆã«ä½¿ç”¨ä¸å¯ã¨åˆ¤æ–­ã•ã‚Œã¾ã—ãŸã€‚`, true);
                tokens.splice(threadTokenIndex, 1);
                if(tokens.length === 0) {
                  updateStatus("ä½¿ç”¨å¯èƒ½ãªTOKENãŒãªããªã‚Šã¾ã—ãŸã€‚", true);
                  break;
                }
                threadTokenIndex = threadTokenIndex % tokens.length;
                continue;
              } else {
                updateStatus(`ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
              }
            }
            threadTokenIndex = (threadTokenIndex + 1) % tokens.length;
            await sleepWithStop(threadDelay, () => threadIsStopped);
          }
          
          updateStatus("ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆå‡¦ç†ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚");
          threadProcessRunning = false;
          document.getElementById("startThreadBtn").disabled = false;
          document.getElementById("stopThreadBtn").disabled = true;
        });
        
        document.getElementById("stopThreadBtn").addEventListener("click", function () {
          threadIsStopped = true;
          updateStatus("ã‚¹ãƒ¬ãƒƒãƒ‰é€ä¿¡ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚");
          document.getElementById("startThreadBtn").disabled = false;
          this.disabled = true;
        });
        
        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ£ãƒ³ãƒãƒ«IDå–å¾—
        document.getElementById("fetchReactionChannelIdButton").addEventListener("click", async function () {
          const serverId = document.getElementById("serverId").value.trim();
          const tokenVal = getTokens()[0] || "";
          if (!serverId) { updateStatus("ã‚µãƒ¼ãƒãƒ¼IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", true); return; }
          if (!tokenVal) { updateStatus("Botãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", true); return; }

          const channelRes = await getChannelsForServer(serverId, [tokenVal]);
          if (channelRes && channelRes.channels.length > 0) {
            document.getElementById("reactionChannelIds").value = channelRes.channels.join("\n");
            updateStatus("ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ£ãƒ³ãƒãƒ«IDã‚’å–å¾—ã—ã¾ã—ãŸã€‚");
          } else {
            updateStatus("ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ£ãƒ³ãƒãƒ«IDã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", true);
          }
        });

        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡å‡¦ç†
        document.getElementById("startReactionBtn").addEventListener("click", async function () {
          // åˆæœŸãƒãƒ£ãƒãƒ«ãƒªã‚¹ãƒˆ
          let reactionChannelIds = document.getElementById("reactionChannelIds").value
            .trim().split("\n").map(id => id.trim()).filter(id => id);
          const normalEmojis = document.getElementById("normalEmojis").value
            .split(",").map(e => e.trim()).filter(e => e);
          const customEmojis = document.getElementById("customEmojis").value
            .split("\n").map(e => e.trim()).filter(e => e);
          const baseEmojis = [...normalEmojis, ...customEmojis];
          const allMessages = document.getElementById("allMessages").checked;
          let reactionMessageCount = parseInt(document.getElementById("reactionMessageCount").value, 10) || 1;
          if (allMessages) reactionMessageCount = null; // nullãªã‚‰å…¨ä»¶å–å¾—æ‰±ã„
          const reactionDelayEnabled = document.getElementById("reactionEnableDelay").checked;
          const reactionDelay = reactionDelayEnabled
            ? (parseInt(document.getElementById("reactionDelay").value, 10) || 0)
            : 0;

          if (reactionChannelIds.length === 0) { updateStatus("ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ£ãƒ³ãƒãƒ«IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", true); return; }
          if (baseEmojis.length === 0)        { updateStatus("ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚", true); return; }
          const tokenVal = getTokens()[0] || "";
          if (!tokenVal) { updateStatus("Botãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", true); return; }

          // åœæ­¢ãƒ•ãƒ©ã‚°åˆæœŸåŒ–ãƒ»ãƒœã‚¿ãƒ³åˆ¶å¾¡
          reactionIsStopped = false;
          document.getElementById("startReactionBtn").disabled = true;
          document.getElementById("stopReactionBtn").disabled = false;

          try {
            // ãƒãƒ£ãƒ³ãƒãƒ«ã‚’é †æ¬¡è©¦ã™ while ãƒ«ãƒ¼ãƒ—
            while (reactionChannelIds.length > 0 && !reactionIsStopped) {
              const channelId = reactionChannelIds[0];
              updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚`);

              let beforeMessageId = null;
              let abortThisChannel = false;
              let processedCount = 0;
              while (!reactionMessageCount || processedCount < reactionMessageCount) {
                const limit = 100;
                let url = `https://discord.com/api/v10/channels/${channelId}/messages?limit=${limit}`;
                if (beforeMessageId) url += `&before=${beforeMessageId}`;
                let resp;
                try {
                  resp = await axios.get(url, { headers: { Authorization: tokenVal } });
                } catch (err) {
                  const status = err.response && err.response.status;
                  if (status === 404 || status === 403) {
                    updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} å–å¾—ã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ${status}ã€‚ã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’é™¤å¤–ã—ã¾ã™ã€‚`, true);
                    reactionChannelIds.shift();
                    document.getElementById("reactionChannelIds").value = reactionChannelIds.join("\n");
                    saveFormData();
                    abortThisChannel = true;
                    break;
                  } else {
                    updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} å–å¾—å¤±æ•—: ${err.message}`, true);
                    reactionChannelIds.shift();
                    document.getElementById("reactionChannelIds").value = reactionChannelIds.join("\n");
                    saveFormData();
                    abortThisChannel = true;
                    break;
                  }
                }
                if (abortThisChannel) break;
                const messages = resp.data;
                if (!messages.length) break;
                beforeMessageId = messages[messages.length - 1].id;
                // æœªãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ½å‡º
                let unreactedMessages = messages.filter(message => {
                  const allEmojis = baseEmojis.map(raw => {
                    if (raw.startsWith("<") && raw.endsWith(">")) raw = raw.slice(1, -1);
                    const parts = raw.split(":");
                    if (parts[0] === "a") parts.shift();
                    return parts.length === 2 ? `${parts[0]}:${parts[1]}` : raw;
                  });
                  const existing = message.reactions
                    ? message.reactions.map(r => r.emoji.id ? `${r.emoji.name}:${r.emoji.id}` : r.emoji.name)
                    : [];
                  const missing = allEmojis.filter(e => !existing.includes(e));
                  return missing.length > 0 && existing.length < 20;
                });
                // ä»¶æ•°åˆ¶é™ã‚ã‚Šã®å ´åˆã¯slice
                if (reactionMessageCount) {
                  const remain = reactionMessageCount - processedCount;
                  unreactedMessages = unreactedMessages.slice(0, remain);
                }
                // å¯¾è±¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                for (const message of unreactedMessages) {
                  if (reactionIsStopped) break;
                  const allEmojis = baseEmojis.map(raw => {
                    if (raw.startsWith("<") && raw.endsWith(">")) raw = raw.slice(1, -1);
                    const parts = raw.split(":");
                    if (parts[0] === "a") parts.shift();
                    return parts.length === 2 ? `${parts[0]}:${parts[1]}` : raw;
                  });
                  const existing = message.reactions
                    ? message.reactions.map(r => r.emoji.id ? `${r.emoji.name}:${r.emoji.id}` : r.emoji.name)
                    : [];
                  const missing = allEmojis.filter(e => !existing.includes(e));
                  if (!missing.length || existing.length >= 20) {
                    updateStatus(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${message.id} ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`);
                    continue;
                  }
                  for (const emoji of missing) {
                    try {
                      await retryRequest(
                        () => axios.put(
                          `https://discord.com/api/v10/channels/${channelId}` +
                          `/messages/${message.id}` +
                          `/reactions/${encodeURIComponent(emoji)}/@me`,
                          {},
                          { headers: { Authorization: tokenVal } }
                        ),
                        1000,
                        () => reactionIsStopped
                      );
                      updateStatus(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${message.id} ã« ${emoji} ã‚’è¿½åŠ `);
                    } catch (err) {
                      const status = err.response && err.response.status;
                      const errCode = err.response && err.response.data && err.response.data.code;
                      if (status === 403 && errCode === 30010) {
                        updateStatus(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${message.id} ã¯ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒæœ€å¤§æ•°ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`);
                        break;
                      } else if ((status === 400 && errCode === 10014) || status === 404 || (status === 403 && errCode === 50013)) {
                        updateStatus(`ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã§ã‚¨ãƒ©ãƒ¼(status:${status}${errCode ? ', code:' + errCode : ''})ã€‚ã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’é™¤å¤–ã—ã¾ã™ã€‚`, true);
                        if (reactionChannelIds[0] === channelId) {
                          reactionChannelIds.shift();
                        } else {
                          const idx = reactionChannelIds.indexOf(channelId);
                          if (idx !== -1) reactionChannelIds.splice(idx, 1);
                        }
                        document.getElementById("reactionChannelIds").value = reactionChannelIds.join("\n");
                        saveFormData();
                        if (reactionChannelIds.length === 0) {
                          reactionIsStopped = true;
                        }
                        abortThisChannel = true;
                        break;
                      } else {
                        updateStatus(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ å¤±æ•—: ${err.message}`, true);
                      }
                    }
                    if (reactionDelayEnabled && !reactionIsStopped) {
                      await sleepWithStop(reactionDelay, () => reactionIsStopped);
                    }
                    if (abortThisChannel) break;
                  }
                  if (abortThisChannel) break;
                  processedCount++;
                  if (reactionMessageCount && processedCount >= reactionMessageCount) break;
                }
                if (abortThisChannel) break;
                if (messages.length < limit) break;
                if (reactionIsStopped) break;
              }

              // ã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã¯æ­£å¸¸å®Œäº† or å…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†å®Œäº† â†’ æ¬¡ã®ãƒãƒ£ãƒ³ãƒãƒ«ã¸
              if (!reactionIsStopped && reactionChannelIds.length > 0 && !abortThisChannel) {
                reactionChannelIds.shift();
                document.getElementById("reactionChannelIds").value = reactionChannelIds.join("\n");
                saveFormData();
              }
            }

            // å…¨ãƒãƒ£ãƒãƒ«è©¦è¡Œå¾Œã¾ãŸã¯åœæ­¢æ™‚ã®ãƒ­ã‚°
            if (reactionIsStopped) {
              updateStatus("ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚");
            } else {
              updateStatus("å…¨ãƒãƒ£ãƒãƒ«ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚");
            }

          } catch (e) {
            updateStatus(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³é€ä¿¡ã‚¨ãƒ©ãƒ¼: ${e.message}`, true);
          } finally {
            document.getElementById("startReactionBtn").disabled = false;
            document.getElementById("stopReactionBtn").disabled = true;
            // ï¼ˆåœæ­¢æ™‚ã«ã“ã“ã§ã¯ä½•ã‚‚å‡ºã—ã¦ã„ãªã‹ã£ãŸï¼‰
            // åœæ­¢ãƒ•ãƒ©ã‚°ã«åŸºã¥ãæœ€çµ‚ãƒ­ã‚°ã‚’ã“ã“ã ã‘ã«ã¾ã¨ã‚ã‚‹
            if (reactionIsStopped) {
              updateStatus("ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚");
            } else {
              updateStatus("å…¨ãƒãƒ£ãƒãƒ«ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚");
            }
          }
        });

        // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³åœæ­¢ãƒœã‚¿ãƒ³
        document.getElementById("stopReactionBtn").addEventListener("click", function () {
          reactionIsStopped = true;
          document.getElementById("startReactionBtn").disabled = false;
          this.disabled = true;
        });


      })();
    </script>
  </body>
</html>
